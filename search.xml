<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/03/17/ji-suan-ji-wang-luo/"/>
      <url>/2023/03/17/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170414.png" alt="img"> </p><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><ol><li>应用层：HTTP （超文本传输协议）DHCP （动态主机配置）DNS （域名系统）FTP（文件传输协议）电子邮件协议（SMTP、POP3、IMAP）</li><li>传输层：TCP （传输控制协议） UDP（用户数据报协议）</li><li>网络层：IP （网际协议） ARP （地址解析协议）</li><li>网络接口层</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思</li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170435.png" alt="HTTP 请求报文结构"> </p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170444.png" alt="HTTP 响应报文结构"> </p><p>常见字段</p><ul><li><em>Host</em> 字段：客户端发送请求时，用来指定服务器的域名。</li><li><em>Content-Length 字段</em>：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</li><li><em>Connection 字段</em>：<code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用</li><li><em>Content-Type 字段</em>：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li><li><em>Content-Encoding 字段</em>：<code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li></ul><p>请求方法</p><ul><li>GET：从服务器获取指定的资源</li><li>POST：根据请求负荷（报文body）对指定的资源做出处理</li><li>PUT：从客户端向服务器传送的数据取代指定的文档的内容</li><li>DELETE：请求服务器删除指定的资源。</li></ul><h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了。</p><p>HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存</p><p><strong>强制缓存</strong></p><p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170452.png" alt="img"> </p><p>强制缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>具体的实现流程如下：</p><ol><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ol><p><strong>协商缓存</strong></p><p>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存（304响应码）</p><blockquote><p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p></blockquote><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，浏览器发现响应头中具有 Last-Modified 声明，则再次向服务器发起请求时，会将请求头 If-Modified-Since  值设置为 Last-Modified 的值。服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>具体实现流程</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p></li><li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p><ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li><p>服务器再次收到请求后，</p><p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p><ul><li>如果值相等，则返回 304 Not Modified，不会返回资源；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源</p></li></ul><h3 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h3><p>HTTP 与 HTTPS 的区别</p><ul><li>端口号 ：HTTP 默认是 80，HTTPS 默认是 443。</li><li>URL 前缀 ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li>安全性和资源消耗 ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 <code>SSL/TLS</code> 之上的 HTTP 协议，<code>SSL/TLS</code> 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li></ul><p>SSL/TLS 基本流程</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>SSL/TLS 工作原理</p><p>混合加密</p><p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式，实现信息的机密性：</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li></ul><p>数字证书</p><p>将服务器公钥放在CA （数字证书认证机构）数颁布的数字证书中，利用数字签名技术防止证书被伪造，确保服务器公钥的可信</p><p>摘要算法 + 数字签名</p><ul><li>摘要算法：使用哈希函数来计算出内容的哈希值，保证传输的内容不被篡改</li><li>数字签名：对内容的哈希值，私钥加密，公钥解密，来确认消息的身份</li></ul><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170503.jpeg" alt="数子证书工作流程">  </p><h3 id="HTTP-1-0-vs-HTTP-1-1"><a href="#HTTP-1-0-vs-HTTP-1-1" class="headerlink" title="HTTP 1.0 vs HTTP 1.1"></a>HTTP 1.0 vs HTTP 1.1</h3><p><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</p><p><strong>状态响应码</strong> : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p><p><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p><strong>Host头处理</strong> : HTTP/1.1在请求头中加入了<code>Host</code>字段</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP：面向连接的，可靠的，基于字节流，一般用于FTP 文件传输，HTTP / HTTPS。</p><p>UDP：无连接的，尽力分发的，基于报文，一般用于即时通信，比如： 语音、 视频 、直播等。</p><h3 id="TCP-头部格式"><a href="#TCP-头部格式" class="headerlink" title="TCP 头部格式"></a>TCP 头部格式</h3><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170510.png" alt="TCP 头格式"></p><p>序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</p><p>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。</p><p>控制位：</p><ul><li>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li><li>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li>SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段</li></ul><h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170516.png" alt="TCP 三次握手"></p><ol><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ol><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>双方确认自己与对方的发送与接收是正常的。</p><p>第一次握手丢失了，客户端就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。</p><p>第二次握手丢失了，客户端就会触发超时重传机制，重传 SYN 报文，服务端也会触发超时重传机制，重传 SYN-ACK 报文。</p><p>第三次握手丢失了，服务端会触发超时重传机制，重传 SYN-ACK 报文。</p><blockquote><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p></blockquote><h4 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>工作流程</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170522.png" alt="正常流程"> </p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li></ul><p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p><h3 id="TCP连接断开"><a href="#TCP连接断开" class="headerlink" title="TCP连接断开"></a>TCP连接断开</h3><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170527.png" alt="客户端主动关闭连接 —— TCP 四次挥手"> </p><ol><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭</li></ol><h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><h4 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h4><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 报文最大生存时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接</p></blockquote><h4 id="为什么需要-TIME-WAIT-状态"><a href="#为什么需要-TIME-WAIT-状态" class="headerlink" title="为什么需要 TIME_WAIT 状态"></a>为什么需要 TIME_WAIT 状态</h4><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li></ul><h3 id="TCP-传输可靠性保障"><a href="#TCP-传输可靠性保障" class="headerlink" title="TCP 传输可靠性保障"></a>TCP 传输可靠性保障</h3><p>TCP 是通过序列号、确认应答、超时重传，流量控制，拥塞控制等机制实现可靠性传输的。</p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170533.jpg" alt="超时重传的两种情况"> </p><blockquote><p>超时时间应该设置为多少呢？</p><p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p></blockquote><p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170541.jpg" alt="快速重传机制"> </p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 利用滑动窗口实现流量控制，让「发送方」根据「接收方」的实际接收能力控制发送的数据量</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170548.png" alt="image-20230306232231678"> </p><p>发送窗口</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170553.png" alt="image-20230306232547896">  </p><p>接受窗口</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170558.png" alt="image-20230306232611877"> </p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制目的就是避免「发送方」的数据填满整个网络。</p><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170605.png" alt="TCP的拥塞控制"> </p><ul><li><p>慢启动（指数增长）</p><p>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</p></li><li><p>拥塞避免（线性增长）</p><p>当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法</p><p>每当收到一个 ACK 时，cwnd 增加 1/cwnd</p></li><li><p>拥塞发生</p><p>发生超时重传的拥塞发生算法：ssthresh 设为 cwnd/2，cwnd 重置为 初始值，进入慢启动</p><p>发生快速重传的拥塞发生算法：ssthresh = cwnd/2，cwnd = ssthresh+3，进入快速恢复</p></li><li><p>快速恢复</p><p>每收到一个重复的ACK拥塞窗口增加1MSS，如果收到新的ACK则拥塞窗口置成阀值</p></li></ul><h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><p><img src="http://blog-liuzhangjie.oss-cn-chengdu.aliyuncs.com/img/2023/20230317170611.png" alt="基于 TCP 协议的客户端和服务端工作"> </p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将 socket 绑定在指定的 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/25/hello-world/"/>
      <url>/2022/02/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/09/15/gitgithub/"/>
      <url>/2021/09/15/gitgithub/</url>
      
        <content type="html"><![CDATA[<h3 id="Git-Github"><a href="#Git-Github" class="headerlink" title="Git/Github"></a>Git/Github</h3><h4 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h4><p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性</p><h4 id="Git工作机制"><a href="#Git工作机制" class="headerlink" title="Git工作机制"></a>Git工作机制</h4><p>工作区（写代码）：本地代码所在磁盘目录</p><p>暂存区（临时存储）：工作区的代码需要添加到暂存区，git add</p><p>本地库（历史版本）：暂存区的代码需要提交到本地库， git commit</p><p>远程库：本地库的代码需要推送到远程库， git push</p><h4 id="Git代码托管中心"><a href="#Git代码托管中心" class="headerlink" title="Git代码托管中心"></a>Git代码托管中心</h4><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库</p><p>局域网</p><p>Gitlab</p><p>互联网</p><p>Github，Gitee</p><h4 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h4><table><thead><tr><th>git config –global user.name 用户名</th><th>设置用户签名</th></tr></thead><tbody><tr><td><strong>git config –global user.email 邮箱</strong></td><td><strong>设置用户签名</strong></td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git log</td><td>查看详细历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h5 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a><strong>设置用户签名</strong></h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name 用户名<span class="token function">git</span> config --global user.email 邮箱</code></pre><p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看<br>到，以此确认本次提交是谁做的。<br>Git 首次安装必须设置一下用户签名，否则无法提交代码。</p><h5 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a><strong>初始化本地库</strong></h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> init</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210918180706745.png" alt="image-20210918180706745"></p><p>生成git文件</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922194624140.png" alt="image-20210922194624140"></p><h5 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a><strong>查看本地库状态</strong></h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> status</code></pre><p>首次查看（工作区没有任何文件）</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922195002788.png" alt="image-20210922195002788"></p><p>新增文件</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922212150633.png" alt="image-20210922212150633"></p><p>查看状态（检测到未追踪的文件）</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922195441045.png" alt="image-20210922195441045"></p><h5 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a><strong>添加暂存区</strong></h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> add</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922195849105.png" alt="image-20210922195849105"></p><p>warning表示换行符自动转换，将linux和unix系统的LF换行符转换为windows系统的CRLF换行符</p><p>查看状态（检测到暂存区有新文件）</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922200626202.png" alt="image-20210922200626202"></p><h5 id="提交本地库"><a href="#提交本地库" class="headerlink" title="提交本地库"></a><strong>提交本地库</strong></h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"日志信息"</span> 文件名</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922211748936.png" alt="image-20210922211748936"></p><p>查看状态（没有文件需要提交）</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922211903048.png" alt="image-20210922211903048"></p><h5 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h5><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922212254201.png" alt="image-20210922212254201"></p><p>查看状态（检测到工作区有文件被修改）</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922212408908.png" alt="image-20210922212408908"></p><p>将修改的文件再次添加暂存区</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922212540712.png" alt="image-20210922212540712"></p><p>查看状态（工作区的修改添加到了暂存区）</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922212649965.png" alt="image-20210922212649965"></p><p>提交本地库</p><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922212842119.png" alt="image-20210922212842119"></p><p>git文件是按行为单位来修改，先删掉被修改的行再重新编辑</p><h5 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a><strong>历史版本</strong></h5><h6 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h6><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reflog //查看版本信息</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922213732303.png" alt="image-20210922213732303"></p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> log//查看版本详细信息</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922213926854.png" alt="image-20210922213926854"></p><h6 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h6><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard 版本号</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210922214343519.png" alt="image-20210922214343519"></p><p>26f03f4为版本号</p><p>Git 切换版本，底层其实是移动的 HEAD 指针，具体原理如下</p><pre class=" language-mermaid"><code class="language-mermaid">graph TD;    head-->master;    master-->fitst;</code></pre><h4 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h4><h5 id="分支作用"><a href="#分支作用" class="headerlink" title="分支作用"></a>分支作用</h5><p><img src="https://img-blog.csdnimg.cn/fead820ba6f34cacb34486385e3e3aca.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM1MzUwNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>分支就是当前工作目录中代码的一份副本。使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">创建分支</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">把指定分支合并到当前分支</td></tr><tr><td align="center">git branch -d/D 分支名称</td><td align="center">删除分支(强制删除)</td></tr></tbody></table><h5 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch -v</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210923160328259.png" alt="image-20210923160328259"></p><h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch 分支名</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210923161654229.png" alt="image-20210923161654229"></p><p>*指示当前分支</p><h5 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout 分支名</code></pre><p><img src="C:\Users\CEO\AppData\Roaming\Typora\typora-user-images\image-20210923162321487.png" alt="image-20210923162321487"></p><h4 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h4><table><thead><tr><th>git remote -v</th><th>查看当前所有远程地址别名</th></tr></thead><tbody><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h5 id="创建远程库别名"><a href="#创建远程库别名" class="headerlink" title="创建远程库别名"></a>创建远程库别名</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> remote -v //查看当前所有远程地址别名<span class="token function">git</span> remove add 别名 远程地址</code></pre><p><img src="C:\Users\CEO\Desktop\捕获2.PNG" alt="捕获2"></p><h5 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push 别名 分支</code></pre><p><img src="C:\Users\CEO\Desktop\捕3.PNG" alt="捕3"></p><h5 id="克隆远程仓库到本地"><a href="#克隆远程仓库到本地" class="headerlink" title="克隆远程仓库到本地"></a>克隆远程仓库到本地</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone 远程地址</code></pre><p><img src="C:\Users\CEO\Desktop\捕获.PNG" alt="捕获"></p><h5 id="拉取远程库内容"><a href="#拉取远程库内容" class="headerlink" title="拉取远程库内容"></a>拉取远程库内容</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull 远程库地址别名 远程分支名</code></pre><p><img src="C:\Users\CEO\Desktop\捕获4.PNG" alt="捕获4"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
